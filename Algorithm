import numpy as np
import matplotlib.pyplot as plt

class TransmissionLine:
    """
    A class to model and analyze a general transmission line.
    """
    def __init__(self, R, L, G, C, freq, length, ZL):
        # Primary Constants and Operating Conditions
        self.R = R  # Resistance per meter (Ohm/m)
        self.L = L  # Inductance per meter (H/m)
        self.G = G  # Conductance per meter (S/m)
        self.C = C  # Capacitance per meter (F/m)
        self.freq = freq  # Frequency (Hz)
        self.length = length  # Length of the line (m)
        self.ZL = complex(ZL)  # Load Impedance (Ohm)

        # Derived values
        self.omega = 2 * np.pi * self.freq

        # Calculate all secondary parameters on initialization
        self._calculate_secondary_constants()
        self.gamma_L = self.calculate_reflection_coefficient()
        self.swr = self.calculate_swr()
        self.Z_in = self.calculate_input_impedance()

    def _calculate_secondary_constants(self):
        """Calculates Z0 (Characteristic Impedance) and gamma (Propagation Constant)."""
        Z_jwL = self.R + 1j * self.omega * self.L
        Y_jwC = self.G + 1j * self.omega * self.C

        self.Z0 = np.sqrt(Z_jwL / Y_jwC)
        self.gamma = np.sqrt(Z_jwL * Y_jwC)
        self.alpha = self.gamma.real # Attenuation constant
        self.beta = self.gamma.imag  # Phase constant

    def calculate_reflection_coefficient(self):
        """Calculates the load reflection coefficient."""
        return (self.ZL - self.Z0) / (self.ZL + self.Z0)

    def calculate_swr(self):
        """Calculates the Standing Wave Ratio (SWR)."""
        return (1 + np.abs(self.gamma_L)) / (1 - np.abs(self.gamma_L))

    def calculate_input_impedance(self):
        """Calculates the input impedance of the line."""
        numerator = self.ZL + self.Z0 * np.tanh(self.gamma * self.length)
        denominator = self.Z0 + self.ZL * np.tanh(self.gamma * self.length)
        return self.Z0 * (numerator / denominator)

    def get_voltage_and_current(self, d):
        """
        Calculates normalized voltage and current at a distance 'd' from the load.
        Assumes incident voltage V0+ is 1 for normalization.
        """
        Vd = np.exp(self.gamma * d) + self.gamma_L * np.exp(-self.gamma * d)
        Id = (1 / self.Z0) * (np.exp(self.gamma * d) - self.gamma_L * np.exp(-self.gamma * d))
        return Vd, Id

    def display_voltage_and_current_at_point(self, d):
        """
        Calculates and prints the voltage and current at a specific distance 'd' from the load.
        """
        if d > self.length or d < 0:
            print(f"Error: Distance {d}m is outside the line length of {self.length}m.")
            return

        Vd, Id = self.get_voltage_and_current(d)
        print(f"\n--- Values at {d} meters from the load ---")
        print(f"Normalized Voltage (Vd): {Vd:.3f}")
        print(f"   - Magnitude: {np.abs(Vd):.3f} V")
        print(f"   - Phase: {np.angle(Vd, deg=True):.2f} degrees")
        print(f"Normalized Current (Id): {Id:.3f} A")
        print(f"   - Magnitude: {np.abs(Id):.3f} A")
        print(f"   - Phase: {np.angle(Id, deg=True):.2f} degrees")
        print("------------------------------------------")


    def plot_waveforms(self):
        """Plots the voltage and current standing wave patterns on separate subplots."""
        d = np.linspace(0, self.length, 500) # Distance from the load
        Vd_vals, Id_vals = self.get_voltage_and_current(d)

        # Create a figure with two subplots, one for voltage and one for current
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), sharex=True)
        fig.suptitle('Voltage and Current Standing Wave Patterns', fontsize=16)

        # --- Voltage Standing Wave Plot ---
        ax1.plot(d, np.abs(Vd_vals), label='|V(d)|', color='blue')
        ax1.set_title('Voltage Standing Wave')
        ax1.set_ylabel('Normalized Voltage Magnitude')
        ax1.grid(True, which='both', linestyle=':')
        ax1.legend()
        V_max = np.max(np.abs(Vd_vals))
        V_min = np.min(np.abs(Vd_vals))
        ax1.text(0.02, 0.95, f'SWR ≈ {V_max/V_min:.3f}', transform=ax1.transAxes, verticalalignment='top',
                 bbox=dict(boxstyle='round,pad=0.5', fc='wheat', alpha=0.5))


        # --- Current Standing Wave Plot ---
        ax2.plot(d, np.abs(Id_vals), label='|I(d)|', color='red')
        ax2.set_title('Current Standing Wave')
        ax2.set_xlabel('Distance from Load (m)')
        ax2.set_ylabel('Normalized Current Magnitude (A)')
        ax2.grid(True, which='both', linestyle=':')
        ax2.legend()

        plt.xlim(0, self.length)
        plt.tight_layout(rect=[0, 0, 1, 0.96]) # Adjust layout to make room for suptitle
        plt.show()

    def summarize(self):
        """Prints a summary of all calculated parameters."""
        print("--- Transmission Line Analysis Summary ---")
        print(f"Frequency: {self.freq/1e6:.2f} MHz")
        print("\nCalculated Secondary Constants:")
        print(f"  - Characteristic Impedance (Z0): {self.Z0:.2f} Ω")
        print(f"  - Propagation Constant (γ): {self.gamma:.4f}")
        print(f"  - Attenuation Constant (α): {self.alpha:.4f} Np/m")
        print(f"  - Phase Constant (β): {self.beta:.4f} rad/m")
        print("\nPerformance Parameters:")
        print(f"  - Load Reflection Coefficient (ΓL): {self.gamma_L:.3f}")
        print(f"  - SWR: {self.swr:.3f}")
        print(f"  - Input Impedance (Z_in): {self.Z_in:.2f} Ω")
        print("------------------------------------------")
